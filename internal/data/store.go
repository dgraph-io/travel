package data

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/dgraph-io/dgo/v2"
	"github.com/dgraph-io/dgo/v2/protos/api"
	"github.com/dgraph-io/travel/internal/advisory"
	"github.com/dgraph-io/travel/internal/places"
	"github.com/dgraph-io/travel/internal/platform/graphql"
	"github.com/dgraph-io/travel/internal/weather"
	"github.com/pkg/errors"
)

type store struct {
	graphql *graphql.GraphQL
	*dgo.Dgraph
}

// City is used to identify if the specified city exists in
// the database. If it doesn't, then the city is added to the database.
// It will return a new City with the city ID from the database.
func (s *store) City(ctx context.Context, city places.City) (string, error) {

	// Define a graphql mutation to add the city to the database. On
	// success we want the new ID for the city generated by the database.
	// Use the addCity function that was generated when we saved the schema.
	mutation := fmt.Sprintf(`
mutation {
	addCity(input: [
		{name: %q, lat: %f, lng: %f}
	])
	{
		city {
			id,
		}
	}
}`, city.Name, city.Lat, city.Lng)

	// Data structure to parse the result of the mutation.
	var result struct {
		AddCity struct {
			City []struct {
				ID string `json:"id"`
			} `json:"city"`
		} `json:"addCity"`
	}

	// Perform the mutation.
	err := s.graphql.Mutate(ctx, mutation, &result)
	if err != nil {
		return "", err
	}

	// Validate we got back the city id.
	if len(result.AddCity.City) != 1 {
		err := errors.New("unable to add city, invalid response for GraphQL mutation")
		return "", err
	}

	return result.AddCity.City[0].ID, nil
}

// Advisory will add the specified Advisory into the database.
func (s *store) Advisory(ctx context.Context, cityID string, advisory advisory.Advisory) error {

	// Define a graphql mutation to add the city to the database. On
	// success we want the new ID for the city generated by the database.
	// Use the addCity function that was generated when we saved the schema.
	adv := fmt.Sprintf(`{
	continent: %q,
	country: %q,
	country_code: %q,
	last_updated: %q,
	message: %q,
	score: %f,
	source: %q
}`,
		advisory.Continent, advisory.Country, advisory.CountryCode,
		advisory.LastUpdated, advisory.Message, advisory.Score, advisory.Source)

	mutation := fmt.Sprintf(`
mutation {
	updateCity(input: [
		{id: %q, advisory: %s}
	])
	{
		city {
			id,
		}
	}
}`, cityID, adv)

	// Data structure to parse the result of the mutation.
	var result struct {
		AddCity struct {
			City []struct {
				ID string `json:"id"`
			} `json:"city"`
		} `json:"addCity"`
	}

	// Perform the mutation.
	err := s.graphql.Mutate(ctx, mutation, &result)
	if err != nil {
		return err
	}

	// Validate we got back the city id.
	if len(result.AddCity.City) != 1 {
		return errors.New("unable to update city, invalid response for GraphQL mutation")
	}

	if result.AddCity.City[0].ID != cityID {
		return errors.New("wrong cityID returned, invalid response for GraphQL mutation")
	}

	return nil
}

// Weather will add the specified Place into the database.
func (s *store) Weather(ctx context.Context, cityID string, w weather.Weather) error {

	// Add the city id to the weather node.
	db := struct {
		CityID string `json:"city_id"`
		weather.Weather
	}{
		CityID:  cityID,
		Weather: w,
	}

	// Convert the data to store into json for the mutation call.
	data, err := json.Marshal(db)
	if err != nil {
		return errors.Wrapf(err, "db[%+v]", db)
	}

	// Define a graphql function to find the weather by its unique id. The
	// cityID will be the unique id for the weather.
	query := fmt.Sprintf(`{ findWeather(func: eq(weather_id, %d)) { id as uid } }`, w.ID)

	//  Define a mutation by connecting the weather to the city with the
	// `weather` relationship.
	mutation := fmt.Sprintf(`{ "uid": "%s", "weather" : %s }`, cityID, string(data))

	// Define and execute a request to add the city if it doesn't exist yet.
	req := api.Request{
		CommitNow: true,
		Query:     query,
		Mutations: []*api.Mutation{
			{
				Cond:    `@if(eq(len(id), 0))`,
				SetJson: []byte(mutation),
			},
		},
	}
	if _, err := s.NewTxn().Do(ctx, &req); err != nil {
		return errors.Wrapf(err, "req[%+v] query[%s] mut[%s]", &req, query, mutation)
	}

	return nil
}

// Place will add the specified Place into the database.
func (s *store) Place(ctx context.Context, cityID string, place places.Place) error {

	// Add the city id to the place node.
	db := struct {
		CityID string `json:"city_id"`
		places.Place
	}{
		CityID: cityID,
		Place:  place,
	}

	// Convert the data to store into json for the mutation call.
	data, err := json.Marshal(db)
	if err != nil {
		return errors.Wrapf(err, "db[%+v]", db)
	}

	// Define a graphql function to find a place by its unique id. The
	// GooglePlaceID will be the unique id for the place.
	query := fmt.Sprintf(`{ findPlace(func: eq(place_id, %s)) { id as uid } }`, place.PlaceID)

	//  Define a mutation by connecting the place to the city with the
	// `places` relationship.
	mutation := fmt.Sprintf(`{ "uid": "%s", "places" : %s }`, cityID, string(data))

	// Define and execute a request to add the city if it doesn't exist yet.
	req := api.Request{
		CommitNow: true,
		Query:     query,
		Mutations: []*api.Mutation{
			{
				Cond:    `@if(eq(len(id), 0))`,
				SetJson: []byte(mutation),
			},
		},
	}
	if _, err := s.NewTxn().Do(ctx, &req); err != nil {
		return errors.Wrapf(err, "req[%+v] query[%s] mut[%s]", &req, query, mutation)
	}

	return nil
}
