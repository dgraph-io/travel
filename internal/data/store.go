package data

import (
	"context"
	"fmt"
	"strings"

	"github.com/dgraph-io/dgo/v2"
	"github.com/dgraph-io/travel/internal/advisory"
	"github.com/dgraph-io/travel/internal/places"
	"github.com/dgraph-io/travel/internal/platform/graphql"
	"github.com/dgraph-io/travel/internal/weather"
	"github.com/pkg/errors"
)

type store struct {
	graphql *graphql.GraphQL
	*dgo.Dgraph
}

// City is used to identify if the specified city exists in
// the database. If it doesn't, then the city is added to the database.
// It will return a new City with the city ID from the database.
func (s *store) City(ctx context.Context, city places.City) (string, error) {

	// Define a graphql mutation to add the city to the database. On
	// success we want the new ID for the city generated by the database.
	mutation := fmt.Sprintf(`
mutation {
	addCity(input: [
		{name: %q, lat: %f, lng: %f}
	])
	{
		city {
			id
		}
	}
}`, city.Name, city.Lat, city.Lng)

	// Data structure to parse the result of the mutation.
	var result struct {
		AddCity struct {
			City []struct {
				ID string `json:"id"`
			} `json:"city"`
		} `json:"addCity"`
	}

	// Perform the mutation.
	err := s.graphql.Mutate(ctx, mutation[1:], &result)
	if err != nil {
		return "", err
	}

	// Validate we got back the city id.
	if len(result.AddCity.City) != 1 {
		return "", errors.New("unable to add city, invalid response for GraphQL mutation")
	}

	return result.AddCity.City[0].ID, nil
}

// Advisory will add the specified Advisory into the database.
func (s *store) Advisory(ctx context.Context, cityID string, advisory advisory.Advisory) error {

	// Define a document that represents the advisory.
	doc := fmt.Sprintf(`
{
	continent: %q,
	country: %q,
	country_code: %q,
	last_updated: %q,
	message: %q,
	score: %f,
	source: %q
}`,
		advisory.Continent, advisory.Country, advisory.CountryCode,
		advisory.LastUpdated, advisory.Message, advisory.Score, advisory.Source)

	// Define a graphql mutation to update the city in the database with
	// the advisory. On success we want to return the ID for the city.
	mutation := fmt.Sprintf(`
mutation {
	updateCity(input: {
		filter: {
		  id: [%q]
		},
		set: {
			advisory: %s
		}
	})
	{
		city {
			id
		}
	}
}`, cityID, doc[1:])

	// Data structure to parse the result of the mutation.
	var result struct {
		UpdCity struct {
			City []struct {
				ID string `json:"id"`
			} `json:"city"`
		} `json:"updateCity"`
	}

	// Perform the mutation.
	err := s.graphql.Mutate(ctx, mutation[1:], &result)
	if err != nil {
		return err
	}

	// Validate we got back the city id.
	if len(result.UpdCity.City) != 1 {
		return errors.New("unable to update city, no city id returned")
	}
	if result.UpdCity.City[0].ID != cityID {
		return errors.New("unable to update city, invalid city id returned")
	}

	return nil
}

// Weather will add the specified Place into the database.
func (s *store) Weather(ctx context.Context, cityID string, weather weather.Weather) error {

	// Define a document that represents the weather.
	doc := fmt.Sprintf(`
{
	city_name: %q,
	description: %q,
	feels_like: %f,
	humidity: %d,
	pressure: %d,
	sunrise: %d,
	sunset: %d,
	temp: %f,
	temp_min: %f,
	temp_max: %f,
	visibility: %q,
	wind_direction: %d,
	wind_speed: %f
}`,
		weather.CityName, weather.Desc, weather.FeelsLike, weather.Humidity,
		weather.Pressure, weather.Sunrise, weather.Sunset, weather.Temp,
		weather.MinTemp, weather.MaxTemp, weather.Visibility, weather.WindDirection,
		weather.WindSpeed)

	// Define a graphql mutation to update the city in the database with
	// the advisory. On success we want to return the ID for the city.
	mutation := fmt.Sprintf(`
mutation {
	updateCity(input: {
		filter: {
		  id: [%q]
		},
		set: {
			weather: %s
		}
	})
	{
		city {
			id
		}
	}
}`, cityID, doc[1:])

	// Data structure to parse the result of the mutation.
	var result struct {
		UpdCity struct {
			City []struct {
				ID string `json:"id"`
			} `json:"city"`
		} `json:"updateCity"`
	}

	// Perform the mutation.
	err := s.graphql.Mutate(ctx, mutation[1:], &result)
	if err != nil {
		return err
	}

	// Validate we got back the city id.
	if len(result.UpdCity.City) != 1 {
		return errors.New("unable to update city, no city id returned")
	}
	if result.UpdCity.City[0].ID != cityID {
		return errors.New("unable to update city, invalid city id returned")
	}

	return nil
}

// Places will add the specified Place into the database.
func (s *store) Places(ctx context.Context, cityID string, places []places.Place) error {

	// Define a collection that represents the places.
	var b strings.Builder
	b.WriteString("[")
	for _, place := range places {
		for i := range place.LocationType {
			place.LocationType[i] = fmt.Sprintf(`"%s"`, place.LocationType[i])
		}
		b.WriteString(fmt.Sprintf(`
{
	address: %q,
	avg_user_rating: %f,
	city_name: %q,
	gmaps_url: %q,
	lat: %f,
	lng: %f,
	location_type: [%q],
	name: %q,
	no_user_rating: %d,
	place_id: %q,
	photo_id: %q
}`,
			place.Address, place.AvgUserRating, place.CityName, place.GmapsURL,
			place.Lat, place.Lng, strings.Join(place.LocationType, ","), place.Name,
			place.NumberOfRatings, place.PlaceID, place.PhotoReferenceID))
	}
	b.WriteString("]")

	// Define a graphql mutation to update the city in the database with
	// the advisory. On success we want to return the ID for the city.
	mutation := fmt.Sprintf(`
mutation {
	updateCity(input: {
		filter: {
		  id: [%q]
		},
		set: {
			places: %s
		}
	})
	{
		city {
			id
		}
	}
}`, cityID, b.String())

	// Data structure to parse the result of the mutation.
	var result struct {
		UpdCity struct {
			City []struct {
				ID string `json:"id"`
			} `json:"city"`
		} `json:"updateCity"`
	}

	// Perform the mutation.
	err := s.graphql.Mutate(ctx, mutation[1:], &result)
	if err != nil {
		return err
	}

	// Validate we got back the city id.
	if len(result.UpdCity.City) != 1 {
		return errors.New("unable to update city, no city id returned")
	}
	if result.UpdCity.City[0].ID != cityID {
		return errors.New("unable to update city, invalid city id returned")
	}

	return nil
}
