directive @hasInverse(field: String!) on FIELD_DEFINITION
directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION
directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION
directive @id on FIELD_DEFINITION
directive @secret(field: String!, pred: String) on OBJECT | INTERFACE
input AddAdvisoryInput {
  continent: String!
  country: String!
  country_code: String!
  last_updated: String
  message: String
  score: Float!
  source: String
}

type AddAdvisoryPayload {
  advisory(order: AdvisoryOrder, first: Int, offset: Int): [Advisory]
  numUids: Int
}

input AddCityInput {
  advisory: AdvisoryRef
  lat: Float!
  lng: Float!
  name: String!
  places: [PlaceRef]
  weather: WeatherRef
}

type AddCityPayload {
  city(filter: CityFilter, order: CityOrder, first: Int, offset: Int): [City]
  numUids: Int
}

input AddPlaceInput {
  address: String
  avg_user_rating: Float
  city_name: String!
  gmaps_url: String
  lat: Float!
  lng: Float!
  location_type: [String]
  name: String!
  no_user_rating: Int
  place_id: String!
  photo_id: String
}

type AddPlacePayload {
  place(order: PlaceOrder, first: Int, offset: Int): [Place]
  numUids: Int
}

input AddWeatherInput {
  city_name: String!
  description: String
  feels_like: Float
  humidity: Int
  pressure: Int
  sunrise: Int
  sunset: Int
  temp: Float
  temp_min: Float
  temp_max: Float
  visibility: String
  wind_direction: Int
  wind_speed: Float
}

type AddWeatherPayload {
  weather(order: WeatherOrder, first: Int, offset: Int): [Weather]
  numUids: Int
}

type Advisory {
  continent: String!
  country: String!
  country_code: String!
  last_updated: String
  message: String
  score: Float!
  source: String
}

input AdvisoryOrder {
  asc: AdvisoryOrderable
  desc: AdvisoryOrderable
  then: AdvisoryOrder
}

enum AdvisoryOrderable {
  continent
  country
  country_code
  last_updated
  message
  score
  source
}

input AdvisoryRef {
  continent: String
  country: String
  country_code: String
  last_updated: String
  message: String
  score: Float
  source: String
}

type City {
  id: ID!
  advisory: Advisory
  lat: Float!
  lng: Float!
  name: String!
  places(order: PlaceOrder, first: Int, offset: Int): [Place]
  weather: Weather
}

input CityFilter {
  id: [ID!]
  name: StringTermFilter
  and: CityFilter
  or: CityFilter
  not: CityFilter
}

input CityOrder {
  asc: CityOrderable
  desc: CityOrderable
  then: CityOrder
}

enum CityOrderable {
  lat
  lng
  name
}

input CityPatch {
  advisory: AdvisoryRef
  lat: Float
  lng: Float
  name: String
  places: [PlaceRef]
  weather: WeatherRef
}

input CityRef {
  id: ID
  advisory: AdvisoryRef
  lat: Float
  lng: Float
  name: String
  places: [PlaceRef]
  weather: WeatherRef
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
}

type DeleteCityPayload {
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
}

type Mutation {
  addCity(input: [AddCityInput!]!): AddCityPayload
  updateCity(input: UpdateCityInput!): UpdateCityPayload
  deleteCity(filter: CityFilter!): DeleteCityPayload
  addAdvisory(input: [AddAdvisoryInput!]!): AddAdvisoryPayload
  addPlace(input: [AddPlaceInput!]!): AddPlacePayload
  addWeather(input: [AddWeatherInput!]!): AddWeatherPayload
}

type Place {
  address: String
  avg_user_rating: Float
  city_name: String!
  gmaps_url: String
  lat: Float!
  lng: Float!
  location_type: [String]
  name: String!
  no_user_rating: Int
  place_id: String!
  photo_id: String
}

input PlaceOrder {
  asc: PlaceOrderable
  desc: PlaceOrderable
  then: PlaceOrder
}

enum PlaceOrderable {
  address
  avg_user_rating
  city_name
  gmaps_url
  lat
  lng
  location_type
  name
  no_user_rating
  place_id
  photo_id
}

input PlaceRef {
  address: String
  avg_user_rating: Float
  city_name: String
  gmaps_url: String
  lat: Float
  lng: Float
  location_type: [String]
  name: String
  no_user_rating: Int
  place_id: String
  photo_id: String
}

type Query {
  getCity(id: ID!): City
  queryCity(
    filter: CityFilter
    order: CityOrder
    first: Int
    offset: Int
  ): [City]
  queryAdvisory(order: AdvisoryOrder, first: Int, offset: Int): [Advisory]
  queryPlace(order: PlaceOrder, first: Int, offset: Int): [Place]
  queryWeather(order: WeatherOrder, first: Int, offset: Int): [Weather]
}

input StringExactFilter {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

input UpdateCityInput {
  filter: CityFilter!
  set: CityPatch
  remove: CityPatch
}

type UpdateCityPayload {
  city(filter: CityFilter, order: CityOrder, first: Int, offset: Int): [City]
  numUids: Int
}

type Weather {
  city_name: String!
  description: String
  feels_like: Float
  humidity: Int
  pressure: Int
  sunrise: Int
  sunset: Int
  temp: Float
  temp_min: Float
  temp_max: Float
  visibility: String
  wind_direction: Int
  wind_speed: Float
}

input WeatherOrder {
  asc: WeatherOrderable
  desc: WeatherOrderable
  then: WeatherOrder
}

enum WeatherOrderable {
  city_name
  description
  feels_like
  humidity
  pressure
  sunrise
  sunset
  temp
  temp_min
  temp_max
  visibility
  wind_direction
  wind_speed
}

input WeatherRef {
  city_name: String
  description: String
  feels_like: Float
  humidity: Int
  pressure: Int
  sunrise: Int
  sunset: Int
  temp: Float
  temp_min: Float
  temp_max: Float
  visibility: String
  wind_direction: Int
  wind_speed: Float
}

